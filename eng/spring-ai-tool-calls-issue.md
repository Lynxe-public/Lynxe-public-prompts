# Spring AI Tool Calls Format Error Solutions

## Problem Description

When using Spring AI for tool calls, you may encounter the following format errors:

### Error Symptoms

The returned `toolCalls` array contains the following issues:

1. **Duplicate tool call IDs**: Two entries use the same `id`
2. **Incomplete fields**:
   - First entry: Has `name` but `arguments` is empty string
   - Second entry: `name` is empty string but `arguments` has value

**Error Example:**
```json
"toolCalls": [
    {
        "id": "call_55b3d0a08a9c4f05bd0bcc",
        "type": "function",
        "name": "browser-service-group_navigate-browser",
        "arguments": ""
    },
    {
        "id": "call_55b3d0a08a9c4f05bd0bcc",
        "type": "function",
        "name": "",
        "arguments": "{\"url\": \"https://www.xiaohongshu.com/explore\"}"
    }
]
```

**Correct Format Should Be:**
```json
"toolCalls": [
    {
        "id": "call_55b3d0a08a9c4f05bd0bcc",
        "type": "function",
        "name": "browser-service-group_navigate-browser",
        "arguments": "{\"url\": \"https://www.xiaohongshu.com/explore\"}"
    }
]
```

## Root Cause Analysis

### 1. Streaming Output Processing Error

When using reactive programming models (such as Flux) for tool calls, the framework may incorrectly split tool calls into multiple incomplete entries when processing chunked data returned by the model.

**Common Errors**:
- Framework may incorrectly treat empty string IDs as valid IDs
- During streaming, tool names and parameters may arrive at different times, causing parsing errors

### 2. JSON Serialization/Deserialization Issues

There may be JSON serialization or deserialization problems during tool calls, causing format errors.

### 3. Non-standard Model Output Format

The tool call format generated by the model may not meet expectations, causing parsing errors.

## Solutions

### Solution 1: Merge and Validate During Tool Call Parsing

When parsing `toolCalls`, check if there are multiple entries with the same ID and merge `name` and `arguments`.

**Implementation Approach:**
```java
// Pseudo code
Map<String, ToolCall> toolCallMap = new HashMap<>();
for (ToolCall call : toolCalls) {
    String id = call.getId();
    if (toolCallMap.containsKey(id)) {
        ToolCall existing = toolCallMap.get(id);
        // Merge name and arguments
        if (existing.getName().isEmpty() && !call.getName().isEmpty()) {
            existing.setName(call.getName());
        }
        if (existing.getArguments().isEmpty() && !call.getArguments().isEmpty()) {
            existing.setArguments(call.getArguments());
        }
    } else {
        toolCallMap.put(id, call);
    }
}
```

### Solution 2: Configure ToolCallingManager

Spring AI provides the `ToolCallingManager` interface to manage the lifecycle of tool execution. Ensure the tool calling manager is properly configured.

**Configuration Example:**
```java
@Bean
ToolCallingManager toolCallingManager() {
    return ToolCallingManager.builder()
        .build();
}
```

Or provide a custom `ToolCallingManager` bean to customize tool execution behavior:

```java
@Bean
ToolCallingManager customToolCallingManager() {
    return new CustomToolCallingManager() {
        @Override
        public List<ToolCall> parseToolCalls(String response) {
            // Custom parsing logic with merge and validation
            List<ToolCall> calls = super.parseToolCalls(response);
            return mergeDuplicateToolCalls(calls);
        }
    };
}
```

### Solution 3: Check Streaming Output Processing Logic

Ensure that tool calls are complete and not split when processing streaming output from the model.

**Recommendations**:
- In streaming processing, wait for complete tool call blocks before parsing
- Implement buffering mechanism to ensure tool call completeness
- Validate tool call completeness (ID, name, arguments are all non-empty)

### Solution 4: Tool Definition and JSON Schema Validation

Ensure tool definitions and input parameter descriptions, required status, and other information are correct.

**Check Points**:
- Tool name must not be empty
- Tool parameters must conform to JSON Schema
- Required parameters must be provided
- Parameter types must be correct

**Example:**
```java
@Bean
Function weatherFunction() {
    return Function.builder()
        .name("getWeather")
        .description("Get weather information")
        .inputSchema(JsonSchemaGenerator.builder()
            .title("WeatherRequest")
            .description("Request for weather information")
            .properties(Map.of(
                "location", JsonSchemaProperty.builder()
                    .type("string")
                    .description("Location name")
                    .required(true)
                    .build()
            ))
            .build())
        .build();
}
```

### Solution 5: Specify Tool Call Format Requirements

When calling the model, explicitly require tool call format specifications to ensure model output meets expectations.

**Add Format Requirements in Prompt:**
```
When making tool calls, ensure:
1. Each tool call has a unique ID
2. The 'name' field must not be empty
3. The 'arguments' field must be a valid JSON string
4. Do not split a single tool call into multiple entries
```

## Best Practices

1. **Validate Tool Call Completeness**: Verify each tool call contains required fields before parsing
2. **Implement Merge Logic**: Automatically merge name and arguments for tool calls with the same ID
3. **Error Handling**: Log and attempt to fix or skip malformed tool calls
4. **Test Coverage**: Write unit tests covering various exception scenarios
5. **Monitoring and Logging**: Log tool call parsing process for troubleshooting

## Reference Resources

- [Spring AI Official Documentation - Tool Calls](https://docs.springframework.org.cn/spring-ai/reference/api/tools.html)
- Spring AI GitHub Issues: Search for related issues and solutions
- Spring AI Community Forum: Get community support

## Update History

- 2025-12-26: Initial version, documenting tool call format errors and solutions

